package controller

import (
	"bytes"
	"image"
	"image/gif"
	"image/jpeg"
	"image/png"
	//"mime/multipart"
	"net/http"

	"github.com/ciela/playground_golang/lgtm_maker/aws"

	"code.google.com/p/go-uuid/uuid"
	"github.com/mitchellh/goamz/s3"
	"github.com/naoina/kocha"
)

const (
	// 最大画像容量(4MB)
	MaxBytes = 4194304
)

type Images struct {
	*kocha.DefaultController
}

func (im *Images) GET(c *kocha.Context) kocha.Result {
	// FIXME: auto-generated by kocha
	return kocha.Render(c)
}

func (im *Images) POST(c *kocha.Context) kocha.Result {
	//リクエスト容量が大きかったら最初から弾く
	if c.Request.ContentLength > MaxBytes {
		return kocha.RenderError(c, http.StatusBadRequest, "Size of your reqest is too large")
	}

	//FormDataの取得
	f, h, err := c.Request.FormFile("image")
	if err != nil {
		return kocha.RenderError(c, http.StatusBadRequest, "Request has not been accepted")
	}
	defer f.Close()

	//ヘッダ情報からの形式取得
	var imgf string
	ct := h.Header["Content-Type"][0]
	switch ct {
	case "image/jpeg":
		imgf = "jpeg"
	case "image/gif":
		imgf = "gif"
	case "image/png":
		imgf = "png"
	default:
		return kocha.RenderError(c, http.StatusBadRequest, "Image format must be either jpeg, gif or png")
	}

	//画像のデコードとフォーマットバリデーション
	img, fm, err := image.Decode(f)
	if err != nil {
		return kocha.RenderError(c, http.StatusBadRequest, "Error has occured when decoding the reqested image")
	} else if fm != imgf {
		return kocha.RenderError(c, http.StatusBadRequest, "The format of actual image is not the same as the header")
	}

	b := new(bytes.Buffer)
	switch imgf {
	case "jpeg":
		err = jpeg.Encode(b, img, nil)
	case "gif":
		err = gif.Encode(b, img, nil)
	case "png":
		err = png.Encode(b, img)
	}
	if err != nil {
		return kocha.RenderError(c, http.StatusBadRequest, "Error has occured when encoding the requested image")
	} else if b.Len() > MaxBytes {
		return kocha.RenderError(c, http.StatusBadRequest, "Actual size of requested image is too large")
	}

	// 配置用のパス決めてS3に配置
	p := uuid.New() //ver4
	if err = aws.LgtmBucket.Put(p, b.Bytes(), ct, s3.PublicRead); err != nil {
		return kocha.RenderError(c, http.StatusInternalServerError, "An error has occured when uploading image")
	}

	// TODO DBにIDを保存

	// FIXME remove nil
	return kocha.Render(c, kocha.Data{"imagePath": p})
}

func (im *Images) PUT(c *kocha.Context) kocha.Result {
	// FIXME: auto-generated by kocha
	//iid := c.Params.Get("imageId")
	return kocha.Render(c)
}

func (im *Images) DELETE(c *kocha.Context) kocha.Result {
	// FIXME: auto-generated by kocha
	//iid := c.Params.Get("imageId")
	return kocha.Render(c)
}

//func decodeJPEG(f *multipart.File, ct *string) (b *bytes.Buffer, err error) {
//	img, err = jpeg.Decode(*f)
//	if err != nil {
//		return
//	}
//	return
//}

//func decodeGIF(f *multipart.File, ct *string) (b *bytes.Buffer, err error) {
//	gImg, err := gif.DecodeAll(*f)
//	if err != nil {
//		return
//	}
//	for _, pi := range gImg.Image { // []*PalletedImage

//	}
//	g := &gif.GIF{
//		Delay:     gImg.Delay,
//		Image:     gImg.Image,
//		LoopCount: gImg.LoopCount,
//	}
//	gif.EncodeAll()
//	return
//}

//func decodePNG(f *multipart.File, ct *string) (b *bytes.Buffer, err error) {
//	img, err = png.Decode(*f)
//	if err != nil {
//		return
//	}
//	return
//}
